<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exposure Time Calculator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="darkroom.css">
    <script>

        // Cookie utility functions
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(cookie.substring(nameEQ.length));
                }
            }
            return null;
        }

        function saveSettings() {
            const settings = {
                paperType: PAPER_TYPE,
                colorHeadType: COLOR_HEAD_TYPE,
                existingFilterGrade: document.getElementById('existingFilterGrade').value,
                updatedFilterGrade: document.getElementById('updatedFilterGrade').value,
                existingY: document.getElementById('existingY').value,
                existingM: document.getElementById('existingM').value,
                existingTime: document.getElementById('existingTime').value,
                updatedY: document.getElementById('updatedY').value,
                updatedM: document.getElementById('updatedM').value
            };
            setCookie('exposureSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const settingsStr = getCookie('exposureSettings');
            if (settingsStr) {
                try {
                    return JSON.parse(settingsStr);
                } catch (e) {
                    console.error('Error parsing settings cookie:', e);
                    return null;
                }
            }
            return null;
        }

        // F-stop calculation and rounding functions
        const FSTOP_STEPS = [1, 1/3, 1/12, 1/24];
        
        function calculateFStops(timeRatio) {
            // Calculate f-stops from time ratio: f-stops = log2(timeRatio)
            return Math.log2(timeRatio);
        }
        
        function roundToNearestFStop(fStops) {
            const absFStops = Math.abs(fStops);
            let bestMatch = { value: absFStops, step: 1, multiplier: absFStops };
            let smallestDiff = Infinity;
            
            // Try each step size and find the best multiple
            for (let step of FSTOP_STEPS) {
                const multiplier = Math.round(absFStops / step);
                const roundedValue = multiplier * step;
                const diff = Math.abs(absFStops - roundedValue);
                
                if (diff < smallestDiff) {
                    smallestDiff = diff;
                    bestMatch = { value: roundedValue, step: step, multiplier: multiplier };
                }
            }
            
            // Return with proper sign
            return fStops >= 0 ? bestMatch.value : -bestMatch.value;
        }
        
        function formatFStops(fStops) {
            const sign = fStops >= 0 ? '+' : '';
            const absFStops = Math.abs(fStops);
            
            // Find the best step representation
            let bestRepresentation = null;
            let smallestDiff = Infinity;
            
            for (let step of FSTOP_STEPS) {
                const multiplier = Math.round(absFStops / step);
                const reconstructed = multiplier * step;
                const diff = Math.abs(absFStops - reconstructed);
                
                if (diff < smallestDiff && multiplier > 0) {
                    smallestDiff = diff;
                    bestRepresentation = { step, multiplier, reconstructed };
                }
            }
            
            if (bestRepresentation && smallestDiff < 0.001) {
                const { step, multiplier } = bestRepresentation;
                
                if (step === 1) {
                    // Whole f-stops
                    return `${sign}${multiplier} f-stop${multiplier !== 1 ? 's' : ''}`;
                } else {
                    // Fractional f-stops
                    const denominator = Math.round(1/step);
                    if (multiplier === 1) {
                        return `${sign}1/${denominator} f-stop`;
                    } else {
                        // Simplify fraction if possible
                        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                        const divisor = gcd(multiplier, denominator);
                        const simplifiedNum = multiplier / divisor;
                        const simplifiedDen = denominator / divisor;
                        
                        if (simplifiedDen === 1) {
                            return `${sign}${simplifiedNum} f-stop${simplifiedNum !== 1 ? 's' : ''}`;
                        } else {
                            return `${sign}${simplifiedNum}/${simplifiedDen} f-stop`;
                        }
                    }
                }
            }
            
            // Fallback for exact values
            return `${sign}${absFStops.toFixed(3)} f-stops`;
        }

        const FILTER_SETTINGS = {
            foma: {
		"00": {Y: 90, M: 0, C: 0 },
                "0": { Y: 60, M: 0, C: 0 },
                "0.5": { Y: 45, M: 0, C: 0 },
                "1": { Y: 30, M: 0, C: 0 },
                "1.5": { Y: 15, M: 0, C: 0 },
                "2": { Y: 0, M: 10, C: 0 },
		"2.5": { Y: 0, M: 15, C: 0 },
                "3": { Y: 0, M: 30, C: 0 },
		"3.5": { Y: 0, M: 60, C: 0 },
                "4": { Y: 0, M: 100, C: 0},
		"4.5": { Y: 0, M: 140, C: 0 },
                "5": { Y: 0, M: 180, C: 0}
            },
            ilford: {
                "00": { Y: 150, M: 0, C: 0 },
                "0": { Y: 90, M: 0, C: 0 },
                "1": { Y: 55, M: 0, C: 0 },
                "2": { Y: 0, M: 0, C: 0 },
                "3": { Y: 0, M: 40, C: 0 },
                "4": { Y: 0, M: 85, C: 0 },
                "5": { Y: 0, M: 150, C: 0 }
            }            
        };

        let PAPER_TYPE = "foma"; // Default paper type
        let COLOR_HEAD_TYPE = "meochrom2"; // Default color head type

        const FILTERING_FACTORS = {
            "meochrom1" : {
                0: [1.00, 1.00, 1.00],
                10: [1.03, 1.10, 1.08],
                20: [1.06, 1.20, 1.15],
                30: [1.08, 1.26, 1.21],
                40: [1.10, 1.33, 1.25],
                50: [1.12, 1.39, 1.30],
                60: [1.13, 1.45, 1.34],
                70: [1.14, 1.50, 1.38],
                80: [1.15, 1.55, 1.42],
                90: [1.16, 1.60, 1.46],
                100: [1.17, 1.66, 1.50],
                110: [1.18, 1.71, 1.54],
                120: [1.18, 1.77, 1.57],
                130: [1.19, 1.82, 1.59],
                140: [1.19, 1.88, 1.62],
                150: [1.20, 1.93, 1.65]
            },
            "meochrom2" : {
                0: [1.00, 1.00, 1.00],
                10: [1.05,1.15,1.09],
                20: [1.10,1.28,1.17],
                30: [1.14,1.39,1.24],
                40: [1.17,1.50,1.30],
                50: [1.20,1.60,1.36],
                60: [1.22,1.69,1.41],
                70: [1.24,1.78,1.46],
                80: [1.25,1.86,1.51],
                90: [1.26,1.94,1.56],
                100: [1.27,2.01,1.60],
                110: [1.28,2.08,1.64],
                120: [1.29,2.14,1.68],
                130: [1.29,2.20,1.72],
                140: [1.30,2.26,1.75],
                150: [1.30,2.31,1.78],
                160: [1.31,2.36,1.81],
                170: [1.31,2.41,1.84],
                180: [1.32,2.45,1.86]
            }
        };

        function interpolate(filteringFactors, value, colorIndex) {
            const keys = Object.keys(filteringFactors).map(Number);
            let lowerKey = keys[0];
            let upperKey = keys[keys.length - 1];

            for (let i = 0; i < keys.length; i++) {
                if (value === keys[i]) {
                    return filteringFactors[value][colorIndex];
                } else if (value < keys[i]) {
                    upperKey = keys[i];
                    lowerKey = keys[i - 1];
                    break;
                }
            }

            const lowerValue = filteringFactors[lowerKey][colorIndex];
            const upperValue = filteringFactors[upperKey][colorIndex];
            return lowerValue + (value - lowerKey) * (upperValue - lowerValue) / (upperKey - lowerKey);
        }

        function calculateExposure() {
            const existingSettings = [
                parseFloat(document.getElementById('existingY').value),
                parseFloat(document.getElementById('existingM').value),
                0
            ];

            const updatedSettings = [
                parseFloat(document.getElementById('updatedY').value),
                parseFloat(document.getElementById('updatedM').value),
                0
            ];

            const existingTime = parseFloat(document.getElementById('existingTime').value);

            // Get the filtering factors for the selected color head type
            const filteringFactors = FILTERING_FACTORS[COLOR_HEAD_TYPE];

            const kY_old = interpolate(filteringFactors, existingSettings[0], 0);
            const kM_old = interpolate(filteringFactors, existingSettings[1], 1);
            const kC_old = interpolate(filteringFactors, existingSettings[2], 2);

            const kY_new = interpolate(filteringFactors, updatedSettings[0], 0);
            const kM_new = interpolate(filteringFactors, updatedSettings[1], 1);
            const kC_new = interpolate(filteringFactors, updatedSettings[2], 2);

            const updatedTime = existingTime * (kY_new / kY_old) * (kM_new / kM_old) * (kC_new / kC_old);
            
            // Calculate f-stop adjustment
            const timeRatio = updatedTime / existingTime;
            const fStopsRaw = calculateFStops(timeRatio);
            const fStopsRounded = roundToNearestFStop(fStopsRaw);
            const fStopDisplay = formatFStops(fStopsRounded);

            document.getElementById('result').innerHTML = `
                Updated Exposure Time: <strong style="color: #ffab40;">${updatedTime.toFixed(2)} seconds</strong><br>
                Adjustment: <strong style="color: #ffab40;">${fStopDisplay}</strong>
            `;
        }
        
        function setFilterSettings(elementId) {
            const filterGrade = document.getElementById(elementId).value;
            const filterSettings = FILTER_SETTINGS[PAPER_TYPE];

            if (filterSettings[filterGrade]) {
                if (elementId === 'existingFilterGrade') {
                    document.getElementById('existingY').value = filterSettings[filterGrade].Y;
                    document.getElementById('existingM').value = filterSettings[filterGrade].M;
                } else if (elementId === 'updatedFilterGrade') {
                    document.getElementById('updatedY').value = filterSettings[filterGrade].Y;
                    document.getElementById('updatedM').value = filterSettings[filterGrade].M;
                }
            }
            saveSettings();
        }
        
        function changePaperType() {
            PAPER_TYPE = document.getElementById('paperType').value;

            // Clear both select elements
            document.getElementById('existingFilterGrade').innerHTML = '';
            document.getElementById('updatedFilterGrade').innerHTML = '';

            // Reload the filter tables
            loadFilterTables();

            // Reset the values
            setFilterSettings('existingFilterGrade');
            setFilterSettings('updatedFilterGrade');

            // Save settings
            saveSettings();
        }

        function changeColorHeadType() {
            COLOR_HEAD_TYPE = document.getElementById('colorHeadType').value;
            saveSettings();
        }
        
        function loadFilterTables() {
            ["existingFilterGrade", "updatedFilterGrade"].forEach(elementId => {
                const selectElement = document.getElementById(elementId);
                const filterSettings = FILTER_SETTINGS[PAPER_TYPE];
                
                // Sort the keys numerically (with special handling for "00")
                const sortedKeys = Object.keys(filterSettings).sort((a, b) => {
                    if (a === "00") return -1;
                    if (b === "00") return 1;
                    return parseFloat(a) - parseFloat(b);
                });
                
                for (const key of sortedKeys) {
                    const optionElement = document.createElement("option");
                    optionElement.value = key;
                    optionElement.text = `Grade ${key}`;
                    selectElement.appendChild(optionElement);
                }
                
                // Select the first option
                if (selectElement.options.length > 0) {
                    selectElement.selectedIndex = sortedKeys.indexOf('2');
                }
            });
        }
        
        window.onload = () => {
            // Try to load saved settings
            const savedSettings = loadSettings();

            if (savedSettings) {
                // Restore paper type and color head type
                if (savedSettings.paperType) {
                    PAPER_TYPE = savedSettings.paperType;
                    document.getElementById('paperType').value = savedSettings.paperType;
                }
                if (savedSettings.colorHeadType) {
                    COLOR_HEAD_TYPE = savedSettings.colorHeadType;
                    document.getElementById('colorHeadType').value = savedSettings.colorHeadType;
                }
            }

            loadFilterTables();

            if (savedSettings) {
                // Restore filter grades
                if (savedSettings.existingFilterGrade) {
                    document.getElementById('existingFilterGrade').value = savedSettings.existingFilterGrade;
                }
                if (savedSettings.updatedFilterGrade) {
                    document.getElementById('updatedFilterGrade').value = savedSettings.updatedFilterGrade;
                }

                // Restore input values
                if (savedSettings.existingY) document.getElementById('existingY').value = savedSettings.existingY;
                if (savedSettings.existingM) document.getElementById('existingM').value = savedSettings.existingM;
                if (savedSettings.existingTime) document.getElementById('existingTime').value = savedSettings.existingTime;
                if (savedSettings.updatedY) document.getElementById('updatedY').value = savedSettings.updatedY;
                if (savedSettings.updatedM) document.getElementById('updatedM').value = savedSettings.updatedM;
            } else {
                // No saved settings, use defaults
                setFilterSettings('existingFilterGrade');
                setFilterSettings('updatedFilterGrade');
            }

            // Add event listeners to save settings when inputs change
            ['existingY', 'existingM', 'existingTime', 'updatedY', 'updatedM'].forEach(id => {
                document.getElementById(id).addEventListener('input', saveSettings);
            });
        };

    </script>
</head>
<body>
    <h1>Exposure Time Calculator</h1>
    <div class="nav-link"><a href="index.html">‚Üê Back to tools</a></div>
    
    <div class="paper-selector">
        <label for="paperType">Paper Type:</label>
        <select id="paperType" onchange="changePaperType()">
            <option value="foma">Foma</option>
            <option value="ilford">Ilford</option>
        </select>
    </div>

    <div class="paper-selector">
        <label for="colorHeadType">Color Head Type:</label>
        <select id="colorHeadType" onchange="changeColorHeadType()">
            <option value="meochrom1">Meochrom 1</option>
            <option value="meochrom2" selected>Meochrom 2</option>
        </select>
    </div>

    <fieldset>
        <legend>Existing:</legend>
        <label for="existingFilterGrade">Filter Grade:</label>
        <select id="existingFilterGrade" onchange="setFilterSettings('existingFilterGrade')">
        </select><br><br>

        <label for="existingY">Yellow Filter Setting:</label>
        <input type="number" id="existingY" value="0"><br><br>

        <label for="existingM">Magenta Filter Setting:</label>
        <input type="number" id="existingM" value="0"><br><br>
        
        <label for="existingTime">Exposure Time (seconds):</label>
        <input type="number" id="existingTime" value="10" step="0.01"><br><br>
    </fieldset>
    
    <fieldset>
        <legend>Updated:</legend>
        <label for="updatedFilterGrade">Filter Grade:</label>
        <select id="updatedFilterGrade" onchange="setFilterSettings('updatedFilterGrade')">
        </select><br><br>
    
        <label for="updatedY">Yellow Filter Setting:</label>
        <input type="number" id="updatedY" value="0"><br><br>
    
        <label for="updatedM">Magenta Filter Setting:</label>
        <input type="number" id="updatedM" value="0"><br><br>
    </fieldset> 

    <button onclick="calculateExposure()">Calculate Updated Time</button>

    <p id="result"></p>
</body>
</html>
