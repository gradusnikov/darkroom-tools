<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Height Exposure Calculator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="darkroom.css">
    <style>
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .controls button {
            flex: 1;
            min-width: 120px;
            margin-top: 0;
        }
        
        
        .results-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #1e1e1e;
            border-radius: 8px;
            border: 1px solid #555;
        }
        
        .instruction-text {
            font-style: italic;
            color: #bdbdbd;
            font-size: 0.9em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Height Exposure Calculator</h1>
    <div class="nav-link"><a href="index.html">← Back to tools</a></div>
    
    <p class="instruction-text">Calculate exposure time adjustments based on EV changes. Fine mode uses 1/24‑stop increments. Coarse modes supported: 1/2, 1/3, 1/4, 1/6, 1/12 stops.</p>

    <label for="deltaEV">ΔEV (EV₁ − EV₂):</label>
    <input id="deltaEV" type="number" step="any" value="1.2">
    <div class="instruction-text">Positive = target is darker (needs more exposure).</div>

    <label for="t1">Reference time t₁ (seconds):</label>
    <input id="t1" type="number" step="any" value="12">


    <label for="stepMode">Step mode (select increment):</label>
    <select id="stepMode">
        <option value="fine">Fine (1/24 stop)</option>
        <option value="1/2">Coarse 1/2 stop</option>
        <option value="1/3">Coarse 1/3 stop</option>
        <option value="1/4">Coarse 1/4 stop</option>
        <option value="1/6">Coarse 1/6 stop</option>
        <option value="1/12">Coarse 1/12 stop</option>
    </select>

    <div class="controls">
        <button id="calc">Compute</button>
        <button id="stepUp">Step ▲</button>
        <button id="stepDown">Step ▼</button>
        <button id="resetSteps">Reset</button>
        <button id="clear">Clear</button>
    </div>


    <div class="results-section">
        <div id="results"></div>
        <div class="instruction-text">Notes: quantization rounds ΔEV to the nearest selected increment. You can then step up/down in single increments (fine = 1/24 stop). Time and aperture update in real time.</div>
    </div>

<script>
// --- Utility functions ---------------------------------------------------
function fmtSec(s){ if (!isFinite(s) || s<=0) return '—'; if (s<0.1) return s.toFixed(3)+' s'; if (s<1) return s.toFixed(2)+' s'; if (s<10) return s.toFixed(2)+' s'; return Math.round(s)+' s'; }
function toNumber(v, fallback=NaN){ const n=Number(v); return isFinite(n)?n:fallback; }

// Map mode string to numeric step fraction (stops)
const STEP_MAP = Object.freeze({
  'fine': 1/24,
  '1/2': 1/2,
  '1/3': 1/3,
  '1/4': 1/4,
  '1/6': 1/6,
  '1/12': 1/12
});

function getStepFraction(mode){ return STEP_MAP.hasOwnProperty(mode) ? STEP_MAP[mode] : 1/24; }
function roundToStep(stops, step){ return Math.round(stops/step)*step; }

// --- Simulator state ----------------------------------------------------
let currentStepCount = 0;   // integer number of step increments
let currentStepFraction = getStepFraction('fine');

// Compute results from step count
function computeFromSteps(stepsCount, stepFraction, t1){
  const totalStops = stepsCount * stepFraction; // can be negative
  const t2 = t1 * Math.pow(2, totalStops);
  return { totalStops, t2, stepsCount };
}

// Update the UI results area
function renderResults(rawDelta, quantizedStops, stepFraction, stepsCount, t1){
  const res = computeFromSteps(stepsCount, stepFraction, t1);
  const perStepFactor = Math.pow(2, stepFraction);
  const out = [];
  out.push('<div style="margin-bottom: 10px;">Raw ΔEV = <strong style="color: #ffab40;">' + Number(rawDelta).toFixed(3) + '</strong> stops</div>');
  out.push('<div style="margin-bottom: 10px;">Step increment = <strong style="color: #ffab40;">1/' + (Math.round(1/stepFraction)) + '</strong> stop (' + stepFraction.toFixed(6) + ' stops)</div>');
  out.push('<div style="margin-bottom: 10px;">Quantized ΔEV = <strong style="color: #ffab40;">' + quantizedStops.toFixed(6) + '</strong> stops → <strong style="color: #ffab40;">' + stepsCount + '</strong> step(s)</div>');
  out.push('<div style="margin-bottom: 15px; padding: 10px; background-color: #2a2a2a; border-radius: 5px; border-left: 4px solid #ff5722;">Adjusted Time = <strong style="color: #ffab40;">' + fmtSec(res.t2) + '</strong></div>');
  out.push('<div class="instruction-text">Per-step exposure factor = ' + perStepFactor.toFixed(6) + '× (each step multiplies time by this)</div>');
  out.push('<div class="instruction-text">Formula used: t₂ = t₁ · 2^{totalStops}</div>');
  document.getElementById('results').innerHTML = out.join('');
}

// Main compute action (quantize and set currentStepCount)
function computeAction(){
  const rawDelta = toNumber(document.getElementById('deltaEV').value, 0);
  const t1 = toNumber(document.getElementById('t1').value, NaN);
  const mode = document.getElementById('stepMode').value;
  if (!isFinite(t1) || t1 <= 0) { alert('Enter positive number for reference time.'); return; }

  const stepFraction = getStepFraction(mode);
  currentStepFraction = stepFraction;
  const quantized = roundToStep(rawDelta, stepFraction);
  const steps = Math.round(quantized / stepFraction);
  currentStepCount = steps;

  // Render
  renderResults(rawDelta, quantized, stepFraction, currentStepCount, t1);
}

// Step up / down actions
function stepUp(){
  const t1 = toNumber(document.getElementById('t1').value, NaN);
  if (!isFinite(t1) || t1 <= 0) { alert('Enter positive number for reference time first.'); return; }
  currentStepCount += 1;
  renderResults(Number(document.getElementById('deltaEV').value||0), currentStepCount*currentStepFraction, currentStepFraction, currentStepCount, t1);
}
function stepDown(){
  const t1 = toNumber(document.getElementById('t1').value, NaN);
  if (!isFinite(t1) || t1 <= 0) { alert('Enter positive number for reference time first.'); return; }
  currentStepCount -= 1;
  renderResults(Number(document.getElementById('deltaEV').value||0), currentStepCount*currentStepFraction, currentStepFraction, currentStepCount, t1);
}
function resetSteps(){
  currentStepCount = 0;
  const t1 = toNumber(document.getElementById('t1').value, NaN);
  renderResults(Number(document.getElementById('deltaEV').value||0), 0, currentStepFraction, 0, t1 || 0.0);
}

// Clear inputs
function clearAll(){
  document.getElementById('deltaEV').value = '';
  document.getElementById('t1').value = '';
  document.getElementById('results').innerHTML = '';
  currentStepCount = 0;
}

// Attach event listeners
document.getElementById('calc').addEventListener('click', computeAction);
document.getElementById('stepUp').addEventListener('click', stepUp);
document.getElementById('stepDown').addEventListener('click', stepDown);
document.getElementById('resetSteps').addEventListener('click', resetSteps);
document.getElementById('clear').addEventListener('click', clearAll);


// Initialize with defaults
computeAction();

</script>
</body>
</html>

